4Sum

https://leetcode.com/problems/4sum/

Awesome. Here is a generalized K Sum solution based on your idea. Got the same high performance.
Using List path to store the selected members, instead of passing them separately.

List<List<Integer>> kSum_Trim(int[] a, int target, int k) {
    List<List<Integer>> result = new ArrayList<>();
    if (a == null || a.length < k || k < 2) return result;
    Arrays.sort(a);
    kSum_Trim(a, target, k, 0, result, new ArrayList<>());
    return result;
}

void kSum_Trim(int[] a, int target, int k, int start, List<List<Integer>> result, List<Integer> path) {
    int max = a[a.length - 1];
    if (a[start] * k > target || max * k < target) return;
    
    if (k == 2) {                        // 2 Sum
        int left = start;
        int right = a.length - 1;
        while (left < right) {
            if      (a[left] + a[right] < target) left++;
            else if (a[left] + a[right] > target) right--;
            else {
                result.add(new ArrayList<>(path));
                result.get(result.size() - 1).addAll(Arrays.asList(a[left], a[right]));
                left++; right--;
                while (left < right && a[left] == a[left - 1]) left++;
                while (left < right && a[right] == a[right + 1]) right--;
            }
        }
    }
    else {                        // k Sum
        for (int i = start; i < a.length - k + 1; i++) {
            if (i > start && a[i] == a[i - 1]) continue;
            if (a[i] + max * (k - 1) < target) continue;
            if (a[i] * k > target) break;
            if (a[i] * k == target) {
                if (a[i + k - 1] == a[i]) {
                    result.add(new ArrayList<>(path));
                    List<Integer> temp = new ArrayList<>();
                    for (int x = 0; x < k; x++) temp.add(a[i]);
                    result.get(result.size() - 1).addAll(temp);    // Add result immediately.
                }
                break;
            }
            path.add(a[i]);
            kSum_Trim(a, target - a[i], k - 1, i + 1, result, path);
            path.remove(path.size() - 1);        // Backtracking
        }
    }
}

--

General Idea
If you have already read and implement the 3sum and 4sum by using the sorting approach: reduce them into 2sum at the end, you might already got the feeling that, all ksum problem can be divided into two problems:

2sum Problem
Reduce K sum problem to K â€“ 1 sum Problem
Therefore, the ideas is simple and straightforward. We could use recursive to solve this problem. Time complexity is O(N^(K-1)).

    public class Solution {
        int len = 0;
        public List<List<Integer>> fourSum(int[] nums, int target) {
            len = nums.length;
            Arrays.sort(nums);
            return kSum(nums, target, 4, 0);
        }
       private ArrayList<List<Integer>> kSum(int[] nums, int target, int k, int index) {
            ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();
            if(index >= len) {
                return res;
            }
            if(k == 2) {
            	int i = index, j = len - 1;
            	while(i < j) {
                    //find a pair
            	    if(target - nums[i] == nums[j]) {
            	    	List<Integer> temp = new ArrayList<>();
                    	temp.add(nums[i]);
                    	temp.add(target-nums[i]);
                        res.add(temp);
                        //skip duplication
                        while(i<j && nums[i]==nums[i+1]) i++;
                        while(i<j && nums[j-1]==nums[j]) j--;
                        i++;
                        j--;
                    //move left bound
            	    } else if (target - nums[i] > nums[j]) {
            	        i++;
                    //move right bound
            	    } else {
            	        j--;
            	    }
            	}
            } else{
                for (int i = index; i < len - k + 1; i++) {
                    //use current number to reduce ksum into k-1sum
                    ArrayList<List<Integer>> temp = kSum(nums, target - nums[i], k-1, i+1);
                    if(temp != null){
                        //add previous results
                        for (List<Integer> t : temp) {
                            t.add(0, nums[i]);
                        }
                        res.addAll(temp);
                    }
                    while (i < len-1 && nums[i] == nums[i+1]) {
                        //skip duplicated numbers
                        i++;
                    }
                }
            }
            return res;
        }
    }

----



